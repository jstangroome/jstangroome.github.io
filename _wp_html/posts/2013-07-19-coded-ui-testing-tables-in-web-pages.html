I recently completed a client engagement that involved building a suite of automated user interface tests for a critical internal web application. The web application has existed for several years and is built to work with Internet Explorer (the client's SOE browser) and the client has also invested heavily in the Microsoft ALM stack including Team Foundation Server, <a href="http://msdn.microsoft.com/en-us/library/vstudio/jj635157.aspx">Test Manager</a>, and some advanced capabilities of <a href="http://msdn.microsoft.com/en-us/library/vstudio/dd997438.aspx">Lab Management</a>. Given this background, <a href="http://msdn.microsoft.com/en-us/library/dd286726.aspx">Coded UI</a> was a suitable technology choice for driving the user interface from tests.

Initially my team and I wanted to take a code-first approach to Coded UI, something similar to the <a href="https://code.google.com/p/selenium/wiki/PageObjects">Page Object pattern</a> commonly used in conjunction with <a href="http://seleniumhq.org">Selenium</a>-based testing. However, given that the test team would be responsible for maintaining the test suite, not the developers, the client pushed for us to build a solution using the Coded UI Test Builder tool to record the tests interactively. From experience I've found that record-and-replay testing approaches tend to be fragile and difficult to maintain so we found a compromise, a hybrid solution.

The design involved having <a href="http://msdn.microsoft.com/en-us/library/ff398062.aspx">a single UIMap (".uitest" file)</a> corresponding to each of the individual pages (or popup windows) in the application. Within each UIMap, we recorded discrete, almost atomic actions, as individual methods (eg "enter text in search box" and "click search button" would be separate methods, recorded separately) and similarly with asserts. We would then hand-code the actual test methods as as series of calls to each of the actions and asserts on the relevant UI Maps, interspersed with control flow code as needed. As an intentional by-product of naming our UIMaps and methods clearly, the hand-coded test methods read very similarly to original manual steps described in each Test Case. Coincidentally, a lot of this approach aligns with <a href="http://msdn.microsoft.com/en-us/library/dd380782.aspx">the recommended practices</a>.

With this hybrid approach, whenever a part of the web application changes, instead of needing to re-record large chunks of actions and tests, only the individual affected pieces need to be updated. The problem with the Coded UI recoding model in general though is dealing with HTML Tables and the application we were testing used Tables to display grids of data and for selecting data on almost every page. When recording actions against a Table with the Coded UI Test Builder it results in code that will later match a cell based on its row and column index or its cell content, or both. This is fine for single-cell actions and assertions but when you need to locate, for example, the cell in the first column containing a specific account number and then click the corresponding cell in the third column on the same row, Coded UI recordings don't help. In fact, the hand-coded equivalent of this scenario using the Coded UI APIs directly isn't great either.

As we progressed through the test cases, we realised the Table scenario needed a good solution. We tried three different approaches over the course of the project and improved incrementally on each based on what we learned. In the end we had a strongly-typed table abstraction that kept the test methods clean and the UIMaps maintainable. The Coded UI Test Builder was still used to record to selection of the HTML &lt;table&gt; element within the page, and we kept the column mapping simple in the UIMap partial class, so we didn't prevent the testers from easily updating the tests with the application.

I have published the <a href="https://github.com/codeassassin/CodedUITable">table abstraction code we used on GitHub</a>, along with a basic DemoWeb application and an accompanying <a href="https://github.com/codeassassin/CodedUITable/blob/master/CodedUITable/DemoWeb.CodedUITests/DemoWebTests.cs">Coded UI test</a> to demonstrate how we use it. <a href="https://github.com/codeassassin/CodedUITable/blob/master/CodedUITable/DemoWeb.CodedUITests/Pages/Default.cs">Here is the Page Object pattern in use</a> where a  particular row structure is defined along with some domain-specific Find and Assert methods.