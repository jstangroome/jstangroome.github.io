I have <a title="Queue another Team Build when one Team Build succeeds" href="http://blog.stangroome.com/2011/09/06/queue-another-team-build-when-one-team-build-succeeds/">previously blogged about queuing a new Team Build at the successful completion of another</a> Team Build for Team Foundation Server 2010. Since then I've had a few people ask how to queue a new Team Build and pass information into the new Team Build via the build process parameters. Recently I've needed to implement this exact behaviour for a client, and with TFS 2013 which has quite different default build process templates, so I thought I'd share it here.

In my situation I'm building on top the default TfvcTemplate.12.xaml process but the same approach can be easily applied to the Git build templates too. <span style="line-height:1.5em;">To begin, I have added two build process parameters to the template:</span>
<ol>
	<li><strong>Chained Build Definition Names</strong> - this is an optional array of strings which refer to the list of Build Definitions that should be queued upon successful completion of the current build. All the builds will be queued immediately and will execute as the controller and agents are available. The current build does not wait for the completion of the builds it queues. My simple implementation only supports queuing builds within the same Team Project.</li>
	<li><strong><span style="line-height:1.5em;">Source </span></strong><span style="line-height:1.5em;"><strong>BuildUri</strong> - this is a single, optional, string which will accept the unique Team Build identifier of the previous build that queued it - this is not intended to be specified by a human but could be. When empty, it is ignored. However, when provided by a preceding build, this URI will be used to retrieve the Build Number and Drop Location of that preceding build and these values, plus the URI, will be made available to the projects and scripts executed within the new build. Following the </span><a style="line-height:1.5em;" href="http://msdn.microsoft.com/en-us/library/dn376353.aspx#env_vars">new Team Build 2013 convention</a><span style="line-height:1.5em;">, these values are passed as environment variables named:</span>
<ul>
	<li>TF_BUILD_<strong>SOURCE</strong>BUILDURI</li>
	<li>TF_BUILD_<strong>SOURCE</strong>BUILDNUMBER</li>
	<li>TF_BUILD_<strong>SOURCE</strong>DROPLOCATION</li>
</ul>
</li>
</ol>
The assumption is that a build definition based on my "chaining" template will only queue other builds based on the same template, or another template which also accepts a SourceBuildUri parameter. This also means that builds can be chained to any depth, each passing the BuildUri of itself to the next build in the chain.

The projects and scripts can use the TF_BUILD_SOURCEDROPLOCATION variable to access the output of the previous build - naturally UNC file share drops are easier to consume <a href="http://msdn.microsoft.com/en-us/library/bb778394.aspx">than drops into TFS itself</a>. Also the TF_BUILD_SOURCEBUILDURI means that the TFS API can be used to query every aspect of the preceding build, notably including the <a href="http://msdn.microsoft.com/en-us/library/microsoft.teamfoundation.build.client.informationnodeconverters.aspx">Information Nodes</a>.

Prior to TFS 2012, queuing a new build from the workflow and passing parameters would have required a custom activity. However, in Team Build 2012 and 2013, Windows Workflow 4.0 is used which includes a new <a href="http://msdn.microsoft.com/en-us/library/dd807388(v=vs.110).aspx">InvokeMethod activity</a> making it possible to add items to the Process Parameters dictionary directly from the XAML.

The <a href="https://gist.github.com/jstangroome/9089053">final XAML for the Build Process Template with support for queuing and passing parameters is available as a Gist</a>. If you'd like to be able to integrate the same functionality with your own Team Build 2013 template you can see the <a href="https://gist.github.com/jstangroome/9089053/revisions">four discrete edits I made to the default TfvcTemplate.12.xaml file from TFS 2013 in the Gist revisions</a>.

When a build using this chaining template queues another build it explicitly sets the <a href="http://msdn.microsoft.com/en-us/library/microsoft.teamfoundation.build.client.ibuildrequest.requestedfor.aspx">RequestedFor property</a> to the same value as the current build so that the chain of builds will show in the <a href="http://msdn.microsoft.com/en-us/library/ms181721.aspx#TeamExplorer">My Builds view</a> of the user who triggered the first build.

<span style="line-height:1.5em;">In my current implementation, the SourceBuildUri passed to each queued build is the URI of the immediately preceding build, but it some cases it may be more appropriate to propagate the BuildUri of the original build that triggered the entire chain. This would be a somewhat trivial change to the workflow for whomever needs this behaviour instead.</span>