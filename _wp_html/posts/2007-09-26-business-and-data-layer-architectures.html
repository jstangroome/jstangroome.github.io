<p>Strongly Typed DataSets in .NET 2.0 do many things very well but they fall short in other places. For a new project I have been researching alternative approaches for structuring the model, logic, and data access projects to allow for easy customisation and good testing. </p> <p>Firstly, there are some features about DataSets that are very useful and would need to exist in any alternative I consider:</p> <ul> <li>Collection filtering and&nbsp;sorting by any properties. <li>Collection and item change notification.  <li>IEditableObject support (ie BeginEdit, EndEdit, CancelEdit).  <li>Excellent encapsulation of SQL commands.</li></ul> <p>There&nbsp;is also the&nbsp;limitations of DataSets that should not exist in&nbsp;the alternative I choose:</p> <ul> <li>Computed values too complex for DataColumn.Expression cannot be bound to.  <li>AllowDBNull and MaxLength violations cause immediate exceptions. <li>Restrictive&nbsp;relationship between model and underlying database structure.  <li>Does not utilise Nullable&lt;T&gt;&nbsp;to support&nbsp;columns that allow DBNull. <li>Change notification&nbsp;events cannot be completely silenced.</li></ul> <p>So far I have briefly investigated <a href="http://www.lhotka.net/cslanet/" target="_blank">CSLA</a>, <a href="http://www.subsonicproject.com/" target="_blank">SubSonic</a>, <a href="http://www.hibernate.org/343.html" target="_blank">NHibernate</a>, and some existing applications both real (<a href="http://code.google.com/p/dotnetkicks/" target="_blank">DotNetKicks</a>) and example (<a href="http://msdn2.microsoft.com/en-us/library/aa479071.aspx" target="_blank">MS Pet Shop</a>), and found that they are all very similar in many ways. Rather than commit myself to a particular framework that may have it's own set of issues I have decided to hand code my own solution to the business and data layering problem.</p> <p><a href="http://notgartner.wordpress.com/2007/09/25/frameworks-frameworks-frameworks/" target="_blank">Others</a> have expressed concerns about going with a third party framework and to a point I agree, but I'm not totally sold either way yet.</p> <p>I intend to watch my own code evolve as I solve the difficulties associated with the task and refactor my work into common classes. I expect that my code will begin to look much like one of the existing frameworks (although that may be biased by what I've already seen) and perhaps I will end up switching to the solution that most closely matches my own.</p> <p>The last thing we need is yet another framework.</p>