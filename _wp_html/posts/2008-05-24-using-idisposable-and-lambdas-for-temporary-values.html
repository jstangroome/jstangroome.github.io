&lt;![CDATA[<p>What follows is some code I wrote last week that I couldn't find anywhere else and I thought was useful. First, is a test method demonstrating my use case, followed by the implementation of the TemporaryValue classes to fulfil the requirement.</p>
<p>The property get lambda expression can be an instance or static property as long as it is read-write. In this implementation there is no exception handling and no multithreading considerations.</p>
<p class="code">[<span class="type">TestMethod</span>]<br /><span class="keyword">public void</span> Original_property_value_should_be_restored_after_temporary_value_block()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const string</span> OriginalValue = <span class="literal">"_original_value_"</span>;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">const string</span> NewValue = <span class="literal">"_new_value_"</span>;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span> f = <span class="keyword">new</span> <span class="type">Foo</span> {Bar = OriginalValue};<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Assert</span>.AreSame(OriginalValue, f.Bar);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">using</span> (<span class="type">TemporaryValue</span>.For(() =&gt; f.Bar, NewValue))<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Assert</span>.AreSame(NewValue, f.Bar);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="type">Assert</span>.AreSame(OriginalValue, f.Bar);<br />}</p>
<p class="code"><span class="keyword">public static class</span> <span class="type">TemporaryValue</span>&nbsp;<br />{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public static</span> <span class="type">TemporaryValue</span> For(<span class="type">Expression</span>&lt;<span class="type">Func</span>&gt; propertyGet, TValue newValue)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return new</span> <span class="type">TemporaryValue</span>(propertyGet, newValue);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />}&nbsp;<br />&nbsp;<br /><span class="keyword">public class</span> <span class="type">TemporaryValue</span> : <span class="type">IDisposable</span>&nbsp;<br />{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">PropertyInfo</span> _propertyInfo;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private object</span> _target;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> TValue _original;&nbsp;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span> <span class="type">TemporaryValue</span>(<span class="type">Expression</span>&lt;<span class="type">Func</span>&gt; propertyGet, TValue newValue)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span> memberExpression = (<span class="type">MemberExpression</span>)propertyGet.Body;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_propertyInfo = (<span class="type">PropertyInfo</span>)memberExpression.Member;&nbsp;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span> targetExpression = memberExpression.<span class="type">Expression</span>;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (<span class="keyword">null</span> != targetExpression)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_target = <span class="type">Expression</span>.Lambda&lt;<span class="type">Func</span>&lt;<span class="keyword">object</span>&gt;&gt;(targetExpression).Compile().Invoke();&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_original = propertyGet.Compile().Invoke();&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set(newValue);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> Set(TValue value)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_propertyInfo.SetValue(_target, value, <span class="keyword">null</span>);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> Dispose()&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (<span class="keyword">null</span> != _propertyInfo)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set(_original);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_propertyInfo = <span class="keyword">null</span>;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_target = <span class="keyword">null</span>;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_original = <span class="keyword">default</span>(TValue);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />}</p>
<p>After learning to manipulate lambda expressions in this way I decided it would be a good idea to use a similar approach to remove the need for string literals in an INotifyPropertyChanged implementation. Unfortunately, while I was offline for a few days, <a href="http://www.paulstovell.com/blog/strongly-typed-property-names">Paul got a head start</a>.</p>]]&gt;