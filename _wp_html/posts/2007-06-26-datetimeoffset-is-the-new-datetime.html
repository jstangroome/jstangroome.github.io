&lt;![CDATA[<p><a href="http://www.flickr.com/photos/jillgood/47241060/" target="_blank"><img title="Photo by Jill and Steven Good" style="border-right:0;border-top:0;margin-bottom:2em;border-left:0;margin-right:2em;border-bottom:0;" alt="Sundial" src="http://www.codeassassin.com/blog/content/binary/WindowsLiveWriter/DateTimeOffsetIsTheNewDateTime_13C70/sundial_1.jpg" align="left" border="0"></a><a href="http://blogs.msdn.com/bclteam/archive/2007/06/14/datetimeoffset-a-new-datetime-structure-in-net-3-5-justin-van-patten.aspx" target="_blank">Justin Van Patten neatly summarises</a> the new <a href="http://msdn2.microsoft.com/en-us/library/system.datetimeoffset(vs.90).aspx" target="_blank">DateTimeOffset</a> class introduced in .NET 3.5. In short, this new class combines the year, month, blah, blah, second storage of the DateTime with a time zone offset. The most important point to take from Justin's article is that apart from a few exceptions (which he describes), you should always use DateTimeOffset in new code instead of the old DateTime.</p>
<p>Naturally there will continue to be situations where you need to pass a DateTime but the DateTimeOffset will always be able to scale back to suit. It is much harder to infer time zone information from a DateTime to provide a DateTimeOffset. I'd love to see the SQL Server team introduce this data type concept to databases.</p>]]&gt;