<strong>Update:</strong> <a href="https://github.com/kubernetes/minikube/releases/tag/v0.29.0">minikube 0.29.0 has been released</a> and includes my <a href="https://github.com/kubernetes/minikube/pull/3065">merged PR</a> so you can enable embedded certificates with <code>minikube config set embed-certs true</code> once and then just symlink your <code>.kube/config</code> file from your WSL home directory to the same file in your Windows home directory.

<hr />

&nbsp;

I recently <a href="http://blog.stangroome.com/2018/06/25/minikube-and-wsl/">blogged about how I work with minikube from the Windows Subsystem for Linux (WSL)</a>, describing some of the friction points and workarounds.

At the time I recommended using the Windows version of kubectl to avoid needing to translate the Windows file paths found in the <code>.kube/config</code> file to be usable with the Linux version of kubectl. Also, I hadn't at that time encountered any use cases where using the Linux kubectl inside WSL would work better than the Windows version.

The first scenario most people would likely encounter with different or breaking behaviour would be passing absolute file paths, e.g. <code>kubectl apply -f /home/jason/my.yaml</code> would usually fail to locate the file with the Windows version. This is worked around most often by using paths relative to the working directory.

Another scenario where the Linux version of kubectl is preferred is the TTY support when running <code>kubectl exec --tty mypod</code>. This was the reason I personally decided to get the Linux version of kubectl working with minikube in my WSL environment.

My first approach was to copy the <code>.kube/config</code> file that is created in my Windows user profile directory during <code>minikube start</code>, modify the three certificate paths to be WSL-compatible paths, and save the result in my WSL home directory.

Later I realised (from the files generated by <code>kubeadm init</code> on production Kubernetes clusters) that the certificate entries in the config file don't need to be paths, but can have the certificate content embedded as base64 blobs. Naturally I wrote <a href="https://gist.github.com/jstangroome/bb72c365ca7b4199e17f7b2e72d64d14">a bash script</a> that I could run from WSL to perform these steps for me each time my minikube IP address or certificates changed (which to be fair, isn't often). The script will use the translated paths approach by default but if executed with the <code>--embed</code> parameter it will use the embedded certificates alternative.

After using this solution for a while I began wondering why minikube didn't just generate a <code>.kube/config</code> file with embedded certificates so WSL support could be solved with a simple symlink instead of copying and rewriting the file each time it changed.

So I dived into the minikube source, and <a href="https://github.com/kubernetes/minikube/pull/3065">raised a pull request</a>, and as at the time of writing this post, the PR has been merged into master and is just awaiting an official release. Once the new version of minikube is published (or if you're keen to build it from source yourself), you will be able to execute <code>minikube config set embed-certs true</code> once and then minikube will always generate a <code>.kube/config</code> file with the certificates embedded as base64 blobs.

Then you can symlink your WSL <code>~/.kube/config</code> file to your Windows <code>%USERPROFILE%/.kube/config</code> file and use either version of kubectl with no ongoing management.

PS: hat tip to <a href="https://twitter.com/nunixtech">Nuno do Carmo</a> who also found a solution to embedding the certificates in the <code>.kube/config</code> file by using a pair of <code>kubectl config ... --embed-certs</code> commands. See the "Bonus 3: Do the same with Minikube" section of his extensive blog on <a href="https://medium.com/@hoxunn/wslinux-k8s-the-interop-way-2d98e5b88f08">WSLinux+K8S: The Interop Way"</a>.